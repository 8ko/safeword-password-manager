/** @preserve
  * package: sweetalert2-react-content v5.0.0
  * file: dist/sweetalert2-react-content.umd.js
  * homepage: https://github.com/sweetalert2/sweetalert2-react-content#readme
  * license: MIT
  **/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react'), require('react-dom')) :
  typeof define === 'function' && define.amd ? define(['react', 'react-dom'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.sweetalert2ReactContent = factory(global.React, global.ReactDOM));
})(this, (function (React, require$$0) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
  var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);

  var createRoot;

  var m = require$$0__default["default"];
  if (process.env.NODE_ENV === 'production') {
    createRoot = m.createRoot;
  } else {
    var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    createRoot = function(c, o) {
      i.usingClientEntryPoint = true;
      try {
        return m.createRoot(c, o);
      } finally {
        i.usingClientEntryPoint = false;
      }
    };
  }

  const mounts = [{
    key: 'title',
    getter: swal => swal.getTitle()
  }, {
    key: 'html',
    getter: swal => swal.getHtmlContainer()
  }, {
    key: 'confirmButtonText',
    getter: swal => swal.getConfirmButton()
  }, {
    key: 'denyButtonText',
    getter: swal => swal.getDenyButton()
  }, {
    key: 'cancelButtonText',
    getter: swal => swal.getCancelButton()
  }, {
    key: 'footer',
    getter: swal => swal.getFooter()
  }, {
    key: 'closeButtonHtml',
    getter: swal => swal.getCloseButton()
  }, {
    key: 'iconHtml',
    getter: swal => swal.getIcon().querySelector('.swal2-icon-content')
  }, {
    key: 'loaderHtml',
    getter: swal => swal.getLoader()
  }];

  const noop = () => {}; // eslint-disable-line @typescript-eslint/no-empty-function


  function withReactContent(ParentSwal) {
    /* Returns `params` separated into a tuple of `reactParams` (the React params that need to be rendered)
    and`otherParams` (all the other parameters, with any React params replaced with a space ' ') */
    function extractReactParams(params) {
      const reactParams = {};
      const otherParams = {};
      const mountKeys = mounts.map(mount => mount.key);
      Object.entries(params).forEach(_ref => {
        let [key, value] = _ref;

        if (mountKeys.includes(key) && /*#__PURE__*/React__default["default"].isValidElement(value)) {
          reactParams[key] = value;
          otherParams[key] = ' ';
        } else {
          otherParams[key] = value;
        }
      });
      return [reactParams, otherParams];
    }

    function render(swal, reactParams) {
      Object.entries(reactParams).forEach(_ref2 => {
        let [key, value] = _ref2;
        const mount = mounts.find(mount => mount.key === key);
        const domElement = mount.getter(ParentSwal);
        const root = createRoot(domElement);
        root.render(value);

        swal.__roots.push(root);
      });
    }

    function unrender(swal) {
      swal.__roots.forEach(root => {
        root.unmount();
      });

      swal.__roots = [];
    }

    return class extends ParentSwal {
      static argsToParams(args) {
        if ( /*#__PURE__*/React__default["default"].isValidElement(args[0]) || /*#__PURE__*/React__default["default"].isValidElement(args[1])) {
          const params = {};
          ['title', 'html', 'icon'].forEach((name, index) => {
            if (args[index] !== undefined) {
              params[name] = args[index];
            }
          });
          return params;
        } else {
          return ParentSwal.argsToParams(args);
        }
      }

      _main(params, mixinParams) {
        this.__roots = [];
        this.__params = Object.assign({}, mixinParams, params);
        const [reactParams, otherParams] = extractReactParams(this.__params);
        const superWillOpen = otherParams.willOpen || noop;
        const superDidOpen = otherParams.didOpen || noop;
        const superDidDestroy = otherParams.didDestroy || noop;
        return super._main(Object.assign({}, otherParams, {
          willOpen: popup => {
            render(this, reactParams);
            superWillOpen(popup);
          },
          didOpen: popup => {
            // read more about why this setTimeout is needed here:
            // https://github.com/reactwg/react-18/discussions/5 (What about the render callback?)
            setTimeout(() => {
              superDidOpen(popup);
            });
          },
          didDestroy: popup => {
            superDidDestroy(popup);
            unrender(this);
          }
        }));
      }

      update(params) {
        Object.assign(this.__params, params);
        unrender(this);
        const [reactParams, otherParams] = extractReactParams(this.__params);
        super.update(otherParams);
        render(this, reactParams);
      }

    };
  }

  return withReactContent;

}));
//# sourceMappingURL=sweetalert2-react-content.umd.js.map
